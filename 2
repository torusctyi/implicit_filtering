
const LINE_SEARCH_REDUCTION: f64 = 0.9;
const STENCIL_REDUCTION: f64 = 0.5;
const ARMIJO_CONSTANT: f64 = 0.9;
const MAX_ITERS: usize = 10;

struct OptimResult{
    x: f64,
    MSE: f64,
}

enum Result<T>{
    Success(T),
    StencilFailure,
}

fn report_stencil_failure(){
    eprintln!("\nStencil Failure\n"); 
}

fn generate_gradient(MSE: &Fn(f64, f64) -> f64, result:  &OptimResult, h: f64) -> Option<f64>{

   let mse_old   = result.MSE;
   let mse_right = MSE(result.x + h,h);
   let mse_left  = MSE(result.x - h,h);

   let grad = (mse_right - mse_left)/(2.0*h);

   if mse_right >= mse_old &&  mse_left >= mse_old{
       return None;
   } else if grad.abs() <= h {
        return None;
   } else { 
        return Some(grad);
   }
}


fn backtracking_line_search(MSE: &Fn(f64, f64) -> f64, x: f64, p: f64, grad: f64, h:f64) -> Option<OptimResult> 
{
    let mse_old  = MSE(x,h);

    for i in 0..MAX_ITERS{

        let a = LINE_SEARCH_REDUCTION.powi(i as i32); 

        let x_new            = x + a*p;
        let mse_new          = MSE(x_new, h);

        let required_decrease =  ARMIJO_CONSTANT*a*p*grad;


        if mse_new - mse_old <= required_decrease{
            return Some(OptimResult{x: x_new, MSE: mse_new}) 
        }
    }

    return None; 
}

fn grad_search(MSE: &Fn(f64, f64) -> f64, x: f64, h: f64) -> Option<OptimResult>{

    let old_result = OptimResult{x: x, MSE: MSE(x,h)};

    let mut current_result = old_result;

    for _i in 0..MAX_ITERS{

        let result  = generate_gradient(MSE, &current_result, h);

        let grad = match result{
                       Some(grad) => grad,
                       None       => break,
                   };
                                  

        let p    = -grad.signum();

        eprintln!("{:10} {:10} {:10}", current_result.x, current_result.MSE, grad.abs());

        let search_result = backtracking_line_search(MSE, current_result.x, p, grad, h);
        match search_result{
            Some(result) => current_result = result,
            None         => {report_stencil_failure();
                             break;},
        };

    }

    if current_result.x == old_result.x || current_result.MSE >= old_result.MSE{
        return None;
    } else {
        return Some(current_result);
    }
}

fn implicit_filtering(MSE: &Fn(f64, f64) -> f64, x0: f64, h0: f64, tol: f64) -> OptimResult{

    let mut old_result = OptimResult{x: x0, MSE: MSE(x0,h0)};

    for i in 0..MAX_ITERS{
        let h :f64 = h0*STENCIL_REDUCTION.powi(i as i32);
        
        let grad_result =  grad_search(MSE, old_result.x, h);

        let new_result = match grad_result{
                           Some(result) => result,
                           None         => continue
                        };

        if (old_result.x - new_result.x).abs() <= tol {
            old_result = new_result;
            break;
        }
    }

    return old_result;
}












        
        
            
        





    





